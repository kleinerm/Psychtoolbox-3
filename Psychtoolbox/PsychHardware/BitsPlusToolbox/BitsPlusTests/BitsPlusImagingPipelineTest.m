function BitsPlusImagingPipelineTest(whichScreen, plotdiffs, forcesuccess)
% BitsPlusImagingPipelineTest([whichScreen][,plotdiffs=0][, forcesuccess=0])
%
% Tests correct function of Mono++ and Color++ mode with imaging pipeline...
% This test script needs to be run once after each graphics card or
% graphics driver or Psychtoolbox upgrade. 
%
% This test tests if the Psychtoolbox image processing pipeline is capable
% to correctly convert a high dynamic range image for the Cambridge
% Research Systems Bits++ box for Mono++ and Color++ mode.
%
% It does so by generating a test stimulus, converting it into a Bits++
% image via the Matlab BitsPlusPlus toolbox and by use of the imaging
% pipeline. Then it reads back and compares the conversion results of both
% to verify that the imaging pipeline produces exactly the same results
% as the Matlab routines.
%
% If the results are the same, it will write some info file to the
% filesystem to confirm this test was successfully run.
%
% Optional parameters:
%
% whichScreen  = Screen id of display to test on. Will be the secondardy
%                display if none provided.
%
% plotdiffs    = If set to one, plot diagnostic difference images, if any
%                differences are detected. By default no such images are plotted. No
%                images will be plotted if no differences exist.
%
% forcesuccess = Set this to one if you want to force the test to succeed,
%                despite detected errors, ie., if you want the GPU
%                conversion to be used. Only use this if you really know
%                what you are doing!
%
% Please note that this test script can only test if the correct output to
% your systems framebuffer is generated by Psychtoolbox. It can't detect if
% the Bits++ box itself is working correctly with this data. Only visual
% inspection and a photometer/colorimeter test can really tell you if the
% whole system is working correctly!

oldverbosity = Screen('Preference', 'Verbosity', 2);

% Define screen:
if nargin < 1 || isempty(whichScreen)
    whichScreen=max(Screen('Screens'));
end

if nargin < 2 || isempty(plotdiffs)
    plotdiffs = 0;
end

if nargin < 3 || isempty(forcesuccess)
    forcesuccess = 0;
end

% Generate a synthetic grating that covers the whole
% color intensity range from 0 to 16384, mapped to the 0.0 - 1.0 range:
theImage=zeros(256,256,3);
theImage(:,:,1)=reshape(double(linspace(0, 2^16 - 1, 2^16)), 256, 256)' / (2^16 - 1);
theImage(:,:,2)=theImage(:,:,1);
theImage(:,:,3)=theImage(:,:,1);

% Convert input image via Bits++ toolbox routines (Matlab code):
fprintf('Converting test stim to color++ format\n');
packedImage = BitsPlusPackColorImage(theImage, 0, 1);
[m,n,p] = size(packedImage);
rect = [0 0 m n];

% Show the image

% Open a double buffered fullscreen window with black background, configured for the Bits++
% Color++ Mode, i.e., with proper setup of imaging pipeline and conversion shaders:
BitsPlusPlus('ForceUnvalidatedRun');
[window, screenRect] = BitsPlusPlus('OpenWindowColor++', whichScreen, 0);

% Find out how big the window is:
[screenWidth, screenHeight]=Screen('WindowSize', window);

% Build HDR texture: 
hdrtexIndex= Screen('MakeTexture', window, theImage, [], [], 2);
dstRect = Screen('Rect', hdrtexIndex);

% Draw HDR image via imaging pipeline:

% Enable Bits++ Color++ output formatter:
Screen('HookFunction', window, 'Enable', 'FinalOutputFormattingBlit');

% Draw Color++ image as generated by PTB GPU imaging pipeline:
dstRect = Screen('Rect', hdrtexIndex);
Screen('DrawTexture',window,hdrtexIndex, [], dstRect, [], 0);

% Finalize image before we take a screenshot:
Screen('DrawingFinished', window, 0, 1);

% Take screenshot of GPU converted image:
convImage=Screen('GetImage', window, ScaleRect(dstRect, 2, 1),'backBuffer');

% Show GPU converted image. Should obviously not make any visual difference if
% it is the same as the Matlab converted image.
vbl = Screen('Flip', window);

% Disable Bits++ Color++ output formatter:
Screen('HookFunction', window, 'Disable', 'FinalOutputFormattingBlit');

% Build and draw texture from packed image:
texpacked= Screen('MakeTexture', window, packedImage);
dstRect = Screen('Rect', texpacked);
Screen('DrawTexture', window, texpacked, [], dstRect, [], 0);

% Show it:
vbl = Screen('Flip', window, vbl + 1);

% Keep it onscreen for 2 seconds, then blank screen:
Screen('Flip', window, vbl + 2);

% Done. Close everything down:
Screen('CloseAll');

% Compute difference images between Matlab converted packedImage and GPU converted
% HDR image:
diffred   = abs(double(packedImage(:,:,1)) - double(convImage(:,:,1)));
diffgreen = abs(double(packedImage(:,:,2)) - double(convImage(:,:,2)));
diffblue  = abs(double(packedImage(:,:,3)) - double(convImage(:,:,3)));

% Compute maximum deviation of framebuffer raw data:
mdr = max(max(diffred));
mdg = max(max(diffgreen));
mdb = max(max(diffblue));

fprintf('Maximum raw data difference: red= %f green = %f blue = %f\n', mdr, mdg, mdb);

% If there is a difference, show plotted difference if requested:
if (mdr>0 || mdg>0 || mdb>0) && plotdiffs
    % Differences detected!
    close all;
    imagesc(diffred);
    figure;
    imagesc(diffgreen);
    figure;
    imagesc(diffblue);
end

if (mdr>0 || mdg>0 || mdb>0)    
    % Now compute a more meaningful difference: The difference between the
    % stimulus as the Bits++ box would see it (i.e. how much do the 16 bit
    % intensity values of each color channel differ?):
    convImage = double(convImage);
    packedImage = double(packedImage);

    % For each color channel do...
    for c=1:3
        % Invert conversion: Compute 16 bpc color values from high/low byte
        % pixel data:
        deconvImage = (zeros(size(convImage,1), size(convImage,2)/2));
        deconvImage(:,:) = 256 * convImage(:, 1:2:end-1, c) + convImage(:, 2:2:end, c);

        depackImage = (zeros(size(packedImage,1), size(packedImage,2)/2));
        depackImage(:,:) = 256 * packedImage(:, 1:2:end-1, c) + packedImage(:, 2:2:end, c);

        % Difference image:
        diffImage = (deconvImage - depackImage);

        % Find locations where pixels differ:
        idxdiff = find(abs(diffImage) > 0);
        numdiff(c) = length(idxdiff);
        numtot(c) = size(diffImage,1)*size(diffImage,2);
        maxdiff(c) = max(max(abs(diffImage)));
        [row col] = ind2sub(size(diffImage), idxdiff);

        % Print out all pixels values which differ, and their difference:
        if plotdiffs
            for j=1:length(row)
                fprintf('Diff: %.2f Input Value: %.20f\n', diffImage(row(j), col(j)), theImage(row(j), col(j), c) * 65535);
            end
        end
    end

    for c=1:3
        % Summarize for this color channel:
        fprintf('Channel %i: %i out of %i pixels differ. The maximum absolute difference is %i.\n', c, numdiff(c), numtot(c), maxdiff(c));
    end
end

if (mdr>0 || mdg>0 || mdb>0) && ~forcesuccess
    fprintf('------------------ DIFFERENCE IN COLOR++ CONVERSION DETECTED ------------------\n');
    fprintf('This should not happen on properly and accurately working graphics hardware.\n');
    fprintf('Either there is a bug in the graphics driver, or something is misconfigured or\n');
    fprintf('your hardware is too old and not capable of performing the calculations in sufficient\n');
    fprintf('precision.\nYou may want to check your configuration and upgrade your driver. If that\n');
    fprintf('does not help, upgrade your graphics hardware. Alternatively you may want to use the old\n');
    fprintf('Matlab-based BitsPlusPackColorImage() function for slow conversion of color images.\n\n');
    fprintf('Please report this failure with a description of your hardware setup to the Psychtoolbox\n');
    fprintf('forum (http://psychtoolbox.org --> Link to the forum.)\n\n');
    fprintf('You can force this test to succeed if you set the optional "forcesuccess" flag for this\n');
    fprintf('script to one and rerun it.\n\n');

    Screen('Preference', 'Verbosity', oldverbosity);
    error('Bits++ Color++ test failed. Results of Matlab code and GPU conversion differ!');
end

fprintf('\n\n------------------- Color++ test success! -------------------------------------\n\n');

% Now test Mono++ formatter:

% Generate a synthetic grating that covers the whole
% intensity range from 0 to 16384, mapped to the 0.0 - 1.0 range:
theImage=zeros(256,256,1);
theImage(:,:)=reshape(double(linspace(0, 2^16 - 1, 2^16)), 256, 256)' / (2^16 - 1);

% Convert input image via Bits++ toolbox routines (Matlab code):
fprintf('Converting test stim to mono++ format\n');
packedImage = BitsPlusPackMonoImage(theImage * (2^16 - 1));
[m,n,p] = size(packedImage);
rect = [0 0 m n];

% Show the image

% Open a double buffered fullscreen window with black background, configured for the Bits++
% Mono++ Mode, i.e., with proper setup of imaging pipeline and conversion shaders:
BitsPlusPlus('ForceUnvalidatedRun');
[window, screenRect] = BitsPlusPlus('OpenWindowMono++', whichScreen, 0);

% Find out how big the window is:
[screenWidth, screenHeight]=Screen('WindowSize', window);

% Build HDR texture: 
hdrtexIndex= Screen('MakeTexture', window, theImage, [], [], 2);

% Draw HDR image via imaging pipeline:

% Enable Bits++ Mono++ output formatter:
Screen('HookFunction', window, 'Enable', 'FinalOutputFormattingBlit');

% Draw Mono++ image as generated by PTB GPU imaging pipeline:
dstRect = Screen('Rect', hdrtexIndex);
Screen('DrawTexture',window,hdrtexIndex, [], dstRect, [], 0);

% Finalize image before we take a screenshot:
Screen('DrawingFinished', window, 0, 1);

% Take screenshot of GPU converted image:
convImage=Screen('GetImage', window, dstRect,'backBuffer');

% Show GPU converted image. Should obviously not make any visual difference if
% it is the same as the Matlab converted image.
vbl = Screen('Flip', window);

% Disable Bits++ Mono++ output formatter:
Screen('HookFunction', window, 'Disable', 'FinalOutputFormattingBlit');

% Build and draw texture from packed image:
texpacked= Screen('MakeTexture', window, packedImage);
dstRect = Screen('Rect', texpacked);
Screen('DrawTexture', window, texpacked, [], dstRect, [], 0);

% Keep it onscreen for 2 seconds, then blank screen:
vbl = Screen('Flip', window, vbl + 2);

% Keep it onscreen for 2 seconds, then blank screen:
Screen('Flip', window, vbl + 2);

Screen('Preference', 'Verbosity', oldverbosity);

% Compute difference images between Matlab converted packedImage and GPU converted
% HDR image:
diffred   = abs(double(packedImage(:,:,1)) - double(convImage(:,:,1)));
diffgreen = abs(double(packedImage(:,:,2)) - double(convImage(:,:,2)));
diffblue  = abs(double(packedImage(:,:,3)) - double(convImage(:,:,3)));

% Compute maximum deviation of framebuffer raw data:
mdr = max(max(diffred));
mdg = max(max(diffgreen));
mdb = max(max(diffblue));

fprintf('\nMaximum raw data difference: red= %f green = %f blue = %f\n', mdr, mdg, mdb);

% If there is a difference, show plotted difference if requested:
if (mdr>0 || mdg>0 || mdb>0) && plotdiffs
    % Differences detected!
    close all;
    imagesc(diffred);
    figure;
    imagesc(diffgreen);
    figure;
    imagesc(diffblue);
end

if (mdr>0 || mdg>0 || mdb>0)    
    % Now compute a more meaningful difference: The difference between the
    % stimulus as the Bits++ box would see it (i.e. how much do the 16 bit
    % intensity values of each color channel differ?):
    convImage = double(convImage);
    packedImage = double(packedImage);

    % Invert conversion: Compute 16 bpc intensity values from high/low byte
    % pixel data:
    deconvImage = zeros(size(convImage,1), size(convImage,2));
    deconvImage(:,:) = 256 * convImage(:, :, 1) + convImage(:, :, 2);

    depackImage = zeros(size(packedImage,1), size(packedImage,2));
    depackImage(:,:) = 256 * packedImage(:, :, 1) + packedImage(:, :, 2);

    % Difference image:
    diffImage = (deconvImage - depackImage);

    % Find locations where pixels differ:
    idxdiff = find(abs(diffImage) > 0);
    numdiff = length(idxdiff);
    numtot = size(diffImage,1)*size(diffImage,2);
    maxdiff = max(max(abs(diffImage)));
    [row col] = ind2sub(size(diffImage), idxdiff);

    % Print out all pixels values which differ, and their difference:
    if plotdiffs
        for j=1:length(row)
            fprintf('Diff: %.2f Input Value: %.20f\n', diffImage(row(j), col(j)), theImage(row(j), col(j)) * 65535);
        end
    end

    % Summarize:
    fprintf('%i out of %i pixels differ. The maximum absolute difference is %i.\n', numdiff, numtot, maxdiff);
end

if (mdr>0 || mdg>0 || mdb>0) && ~forcesuccess
    fprintf('------------------ DIFFERENCE IN MONO++ CONVERSION DETECTED ------------------\n');
    fprintf('This should not happen on properly and accurately working graphics hardware.\n');
    fprintf('Either there is a bug in the graphics driver, or something is misconfigured or\n');
    fprintf('your hardware is too old and not capable of performing the calculations in sufficient\n');
    fprintf('precision.\nYou may want to check your configuration and upgrade your driver. If that\n');
    fprintf('does not help, upgrade your graphics hardware. Alternatively you may want to use the old\n');
    fprintf('Matlab-based BitsPlusPackMonoImage() function for slow conversion of luminance images.\n\n');
    fprintf('Please report this failure with a description of your hardware setup to the Psychtoolbox\n');
    fprintf('forum (http://psychtoolbox.org --> Link to the forum.)\n\n');
    fprintf('You can force this test to succeed if you set the optional "forcesuccess" flag for this\n');
    fprintf('script to one and rerun it.\n\n');
    sca;
    error('Bits++ Mono++ test failed. Results of Matlab code and GPU conversion differ!');
end

fprintf('\n\n------------------- Mono++ test success! -------------------------------------\n\n');

% All tests successful: Write this configuration to file as being
% validated:
BitsPlusPlus('StoreValidation', window);

% Done. Close everything down:
Screen('CloseAll');

fprintf('BitsPlusPlus imaging pipeline verified to work correctly. Validation info stored.\n');

% Done for now.
return;
